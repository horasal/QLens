use std::fmt::Display;

use async_openai::types::{
    ChatCompletionRequestAssistantMessageContentPart, ChatCompletionRequestMessageContentPartText,
    ChatCompletionRequestSystemMessageContentPart,
};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ChatMeta {
    id: Uuid,
    date: DateTime<Utc>,
    summary: String,
}

impl From<ChatEntry> for ChatMeta {
    fn from(value: ChatEntry) -> Self {
        Self {
            id: value.id,
            date: value.date,
            summary: value.summary,
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ChatEntry {
    pub id: Uuid,
    pub date: DateTime<Utc>,
    pub summary: String,
    pub messages: Vec<Message>,
}

impl Default for ChatEntry {
    fn default() -> Self {
        Self {
            id: Uuid::new_v4(),
            date: Utc::now(),
            summary: String::new(),
            messages: vec![],
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Message {
    #[serde(default = "Uuid::new_v4")]
    pub id: Uuid,
    pub owner: Role,
    pub reasoning: Vec<MessageContent>,
    pub content: Vec<MessageContent>,
    pub tool_use: Vec<ToolUse>,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
#[serde(tag = "role", content = "tool_call_id")]
pub enum Role {
    User,
    Assistant,
    System,
    /// Response from tools and its Origin UUID from tool_use
    #[serde(rename = "tool")]
    Tools(Uuid),
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum MessageContent {
    Text(String),
    // uuid in database, additional description(e.g. label generated by llm)
    ImageRef(Uuid, String),
    ImageBin(Vec<u8>, Uuid, String),
}

impl Display for MessageContent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            MessageContent::Text(s) => write!(f, "{}", s),
            MessageContent::ImageRef(id, s) => {
                write!(f, "{{\"image_idx\":\"{}\",\"description\":\"{}\"}}", id, s)
            }
            MessageContent::ImageBin(_, id, s) => {
                write!(f, "{{\"image_idx\":\"{}\",\"description\":\"{}\"}}", id, s)
            }
        }
    }
}

impl Into<ChatCompletionRequestAssistantMessageContentPart> for MessageContent {
    fn into(self) -> ChatCompletionRequestAssistantMessageContentPart {
        ChatCompletionRequestAssistantMessageContentPart::Text(
            ChatCompletionRequestMessageContentPartText {
                text: self.to_string(),
            },
        )
    }
}

impl Into<ChatCompletionRequestSystemMessageContentPart> for MessageContent {
    fn into(self) -> ChatCompletionRequestSystemMessageContentPart {
        ChatCompletionRequestSystemMessageContentPart::Text(
            ChatCompletionRequestMessageContentPartText {
                text: self.to_string(),
            },
        )
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ToolUse {
    #[serde(default = "Uuid::new_v4")]
    pub use_id: Uuid,
    pub function_name: String,
    pub args: String,
}
